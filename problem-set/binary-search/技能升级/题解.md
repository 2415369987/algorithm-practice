通过题目可知，对于给定的每个 $(A_i, B_i)$ 二元组，都可以构成一组有限项的递减等差数列。一共有 $n$ 个组，那么构成了 $n$ 个等差数列。

因为对于每组数列，只能选择首项，选完之后将首先删去，得到新的首项。所以我们的目标是在 $n$ 组等差数列中按照指定的选择次序选择 $m$ 个数，使得可以提高的攻击力最大。

该题目可考虑多路归并思想。制定贪心策略，将每个数列合并在一起构成一个集合，然后从集合中选择最大的 $m$ 个数相加。这里需要注意的是，原问题的选择是有限制的，也就是说，假设相集合中最大的 $m$ 个数之和为 $s$，则从 $n$ 组等差数列中选择的 $m$ 个数之和为 $t$，那么 $t\leq m$，这里我们需要证明 $t=m$，才可以使用这个方案。

证明过程比较简单，先从集合中选择最大的数，因为数列递减，那么这个数一定是某个数列的首项，可以选到，然后在这个数列中删去该数。在从集合中选择第二大的数，同理，依旧可以选到，以此类推，对于集合中的前 $m$ 大的数，若我们按照从小到大的方式在 $n$ 个数列中进行选择，则一定可以选到，即成功证明：
$t = m$。

于是得到一个思路：将这个 $n$ 个数列全部放到一个大根堆中，每次取堆顶的数，取 $m$ 次，得到答案。

分析时间复杂度：将 $n$ 个数列放进堆中需要 $n\times{\lceil{\frac{A_i}{B_i}}\rceil}$ 次操作，然后 $m$ 次取出操作，每次取出操作的时间复杂度 $O(\log{n})$，即时间复杂度为 $O(max({\lceil{\frac{A_i}{B_i}}\rceil}n,m\log{n}))$，这里 $m$ 高达 $20$ 亿，所以需要考虑优化。

重新分析问题，可以发现我们的目的是找到前 $m$ 大的数然后求和。那么我们考虑，是否当我们找到第 $m$ 大的数时，可以通过该数在这 $n$ 组数列中找到前 $m$ 大的数。

假设第 $m$ 大的数为 $x$，可以发现，对于任意数列 $(A_i,B_i)$ 的任意一项都可以写成 $A_i-kB_i$ 的形式，那么只要找到满足 $A_i-kB_i\geq x$ 的最大的 $k$，就可以知道该数列中最后一个大于等于 $x$ 数，然后通过等差求和公式，可以求出该数列中所有大于等于 $x$ 的数的和。

然后遍历每个数列，就可以求出所有大于等于 $x$ 的数之和，需要注意，这里求和的结果是可能大于最大的前 $m$ 个数之和的，因为 $\geq$ $x$ 的数是可能会超过 $m$ 的，所以在枚举的时候需要使用一个计数器去记录大于等于 $x$ 的数的个数，最后减去多余数即可。

我们发现，当我们找到第 $m$ 大的数时，可以解决该问题。于是现在问题就转变为了如何找到第 $m$ 大的数。这是一个经典的二分模型，在一个集合中找到第 $m$ 大的数。

将集合中的数按从小到大排序，这里假设第 $m$ 大数为 $t$，那么大于 $t$ 的数的个数一定小于 $m$，而大于等于 $t$ 的数的个数是大于等于 $m$ 的。我们二分出一个 $mid$，然后在在所有数列中找出大于等于 $mid$ 的数的个数，若小于 $m$，则满足严格大于 $t$，缩小 $r$，反之缩小 $l$。

![image-20250331203007941](C:\Users\GOD\AppData\Roaming\Typora\typora-user-images\image-20250331203007941.png)

在数列中找出大于等于 $mid$ 的数的个数的方法类似于上面求解前 $m$ 大的数之和，不多赘述。

